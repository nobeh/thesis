% -*- root: ../thesis.tex -*-

\chapter[Introduction]{Introduction}
\label{ch:intro}

\section{From actor \emph{modelling} to actor \emph{programming}}
\label{sec:intro:abs}

Object-oriented programming~\cite{booch1982object,meyer1988object} has been of one the dominant paradigms for software engineering in the past three decades.
One object interacts with another object using the notion of a method.
Method invocations are \emph{blocking}; i.e. the caller object waits until it receives the result of the method call from the callee object.
Surprisingly, this model of interaction was \emph{never} the intention of the creator of the paradigm.
Originally, object interactions were meant to be \emph{messages} among objects and objects behaved as autonomous entities possibly on remote locations on a network; Alan Kay clarified later~\cite{alank1,alank2}. 
On the contrary, almost all the object-oriented languages at hand have followed the blocking and synchronous model of messaging. 
The original definition of object-oriented programming is close to another model of computation: actor model.  

One of the fundamental elements of actor model~\cite{actors:agha,agha97} is \emph{asynchronous} message passing.
In this approach, interactions between objects are modelled as \emph{non-blocking} messages.
One object, the sender, communicates a message to the other object, the receiver.
At the receiver side, a message eventually leads to a method invocation (in the object-oriented paradigm) or a function call (in the functional paradigm).
Actor model features location transparency; i.e. the physical location of objects is not visible to other objects.
A system is composed of objects that communicate through messages.

A considerable amount of research has been carried out to mix object-oriented programming languages with the actor model~\cite{philippsen2000survey}. 
Language extensions, libraries, and even new programming languages are the natural outcomes of such research.
The more mainstream the language, the more research and development are available in the intersection of object orientation and actor model.
For example, \cite{actor_frameworks_jvm:agha} presents a comparative analysis of such research for Java and JVM languages.

The rapid increase of computational power added a new aspect to create a triangle: object-oriented, actor model, and \emph{concurrency}.
Concurrency makes it harder to verify programs in terms of correctness of runtime behavior~\cite{Herlihy:1990:linear,johnsen:history,agha:predictive:safety}. 
Scheduling of object messages in threads of executions is one of main challenges.
In addition, in the presence of scheduling and thread interleaving, it is important that objects are able to protect their state from concurrent modifications for correctness properties.

The core contributions of this thesis target at the intersection of object 
orientation, actor model, and concurrency.
We choose Java as the main programming language and as one of the mainstream 
object-oriented languages. 
We formalize a subset of Java and its concurrency API~\cite{jsr166} to 
facilitate formal verification and reasoning about it.
We create an abstract mapping from a concurrent-object modelling language, 
ABS~\cite{johnsen2012abs}, to programming semantics of Java concurrency. 
We provide the formal semantics of the mapping and runtime properties of 
the concurrency layer including deadlines and scheduling policies.
We provide an implementation of ABS concurrency layer as a Java API library 
and framework utilizing the latest langauge additions 
in Java 8~\cite{jsr335:lambda:translation}.
We design and implement a runtime monitoring framework, JMSeq, to verify the
sequenced execution of methods through code annotatinon in JVM. 
In addition, we design a large-scale monitoring system as a real-world 
application; the monitoring system is built with actors and ABS concurrency 
with formal semantics of ABS composed with schedulability 
analysis~\cite{fersman2007task}.
We elaborate on the elements of this research in the following.

ABS~\cite{johnsen2012abs,hahnlehjlssw11} is a modelling language for concurrent objects and distributed systems.
ABS is based on the semantics of the actor model~\cite{actors:agha}.
ABS language provides a set of core features including algebraic data types (ADT), a functional layer, and a concurrency layer.
The ABS concurrency layer uses co-operative scheduling of active objects~\cite{creol:broch:owe}.
ABS semantics is completely expressed in structural operational semantics~\cite{plotkin:sos}.
This allows ABS models to take advantage of various verification methods and static analysis techniques.
% 
Co-operative scheduling in ABS has been additionally extended for real-time scheduling taking priorities and time constraintsinto account~\cite{bjork2013:rtabs,johnsen2012modeling}.
All the above characteristics make the ABS language an attractive choice if it
can be used as a programming language at industrial and business scale.
However, ABS has so far remained mainly as a modelling language.
\TODO{Check with Frank.}

One core challenge is to combine ABS semantics (e.g. concurrency layer) in a
programming language.
Considering the mainstream programming languages
\footnote{\url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html}}, Java~\cite{gosling2000java} is one of the most commonly-used.
Since Java 1.5 and the rise of the concurrency API in Java~\cite{jsr166}, substantial effort is spend by the community on how concurrency and distribution can be improved in Java, along the lines of the actor model, as provided by ABS.
However, not all the development on Java libraries and frameworks are based on a rigorous formal semantics. 
Therefore, this gives rise to issues and challenges in terms of correctness, semantic preservation, and reasoning.

% We deliver ABS concurrency layer in form of a Java library API.
% However, 
The Java language specification (JLS)~\cite{gosling2000java} clearly concludes that Java language is not comptabile and ready to be extended with a functional language that supports algebraic data types.
This has been the focus of research and development to extend Java to a functional language~\cite{odersky1997pizza,henkel2003discovering,nystrom2003polyglot,bracha1998making}.
The Scala language~\cite{odersky2004scala} is a result of the research. It is a dynamic, functional, and object-oriented language on JVM.
However, these extensions and libraries lack formal semantics in the context
of concurrency and actor model.

We primarily focus on ABS concurrency layer and deliver its semantics as a Java API.
We argue that the advantage of a correct semantic translation from ABS concurrency layer to its Java equivalent constructs overcomes the additional support of functional layer with \emph{partial} formal semantics.
Our approach enables programmers to model their Java systems in terms of ABS concurrency semantics and then create a correct mapping and implementation from ABS to Java using an API.
In addition, we aim to facilitate ways to actually program ABS models taking advantage of the standard Java libraries.

\section{Architecture}
\label{sec:intro:arch:crit}

In this section, we present a high-level overview of design goals that we pursue in this research. 
%Equivalently, the effectiveness and success of this research is measured upon the achievement of the discussed goals and objectives. 

\paragraph{Polyglot Programming}
With the rise of distributed computing challenges, software engineering practice has turned to methods that combine multiple programming languages and models to complete a task. 
In this approach, different languages with different focus and abstractions contribute to the same problem statement in different layers. 
Polyglot programming essentially enables software practice to apply the \emph{right} language in the appropriate layer of the problem statement. 
In this research, we aim to deliver ABS semantics and features in a polyglot approach. 
The programmer develops models with ABS that \emph{partially} take advantage of the target language features (e.g. from Java).
This approach is also referred to as \emph{Foreign Function Interface} in the context of ABS modelling.
Listing~\ref{lst:abs:java} shows ABS code that uses \jtt{java.util.ArrayList} as a data strucuture.
With Polyglot programming in ABS, the programmer does \emph{not} need to define the abstractions necessary for the list construct. 

\begin{lstlisting}[float=h,language=Java,caption=Using Java in ABS,label=lst:abs:java]
List<String> params = new ArrayList<>();    // Java
myObj ! doSomething(params);                // ABS
\end{lstlisting}

\paragraph{Scalability} 
Asynchronous message passing in ABS is a fit for distributed systems.
In such systems, the number of messsages delivered among actors in the 
environment is not predictable at runtime.
Therefore, distribution challenges performance efficiency or scalability.
The goal is to ensure the actor system scales in performance with least 
influence from the number of asynchronous messages delivered in the system.
\TODO{Discuss with Frank and drop this.}

\paragraph{Modularity} 
One of the main goals of this research is to create a modular and reusable
software artifact. 
This can be achieved only by producing an API for ABS semantics that is
indepedent from any specific ABS backend.
\TODO{Elaborate on why an API library is modular for ABS}
The scope of the research spans to a number of layers revolving around ABS
 language:
\begin{itemize}
\item \emph{Compiling ABS to a target programming language}
One first objective is to compile an ABS model to a target programming language.
% The compilation can be at \emph{source-to-source} or \emph{source-to-bytecode} level.
In addition, to be able to integrate generated code from ABS into other legacy systems, it is crucial that generated code is readable and of acceptable quality.\TODO{Use software engineering terms here}
Target languages potentially include mainstream programming languages such as
Java, Erlang, Haskell, and Scala.
Thus, the ABS programmer should be able to use an ABS compiler to compile
their ABS models to the target languages.
\TODO{Why not the previous ABS Java backend suffered from software engineering}
\item \emph{Using ABS concurrency as an API in an existing programming language}
The ABS language is precisely expressed with structural operational semantics~\cite{johnsen2012abs} in addition to its syntax definition.
The semantics of ABS can be delivered in a programming language
as Application Programming Interface (API) as long as the programming language provides sufficient constructs to respect ABS language semantics.
In addition, such ABS programming API should be \emph{verifiable}.
If an ABS mapping to a programming API is provided, a programmer is able to
take advantage of ABS semantics without directly programming in ABS.
Such capability from ABS enables industry users of mainstream languages to
model their systems in ABS semantics using their programming languages and
platforms.
\item \emph{Modelling in ABS}
ABS language provides a rigorous semantics to model concurrent
and distributed systems.
For practical reasons, the user (that can be a programmer, an analysist, or a researcher) 
desires to have access to a tool-set and IDE that allows working with ABS 
models in a user-friendly way.
The ABS IDE and tool-set developers should be able to easily reuse and compose
over existing modules and components.
\end{itemize}

% Based on the scopes and layers of usage of this research, we aim to provide 
% a highly modular architecture in design and implementation.
% The goal is verifiable based on produced artifacts of this research in terms
% of their \emph{usability}, \emph{re-usability}, and \emph{composability} in
% different contexts.

\paragraph{Extensibility}
It is a common practice in software engineering that components are developed with a mixture of \emph{configuration}, \emph{extension} and \emph{composition}.
Hence, delivering the ABS language features as an API brings about a new requirement: to configure or extend the API. 
In particular, the ABS programmer should be able to extend the API to customized requirements. \TODO{Expand?}
%The extensibility is provided either through configuration of the API or API extension.

\Behrooz{It's worth to include the figure but needs more work to justify its presence and how it relates to this thesis.}
Figure~\ref{fig:arch} presents the general architecture of the implementation.

\TODO{Relate the criteria in this section on how they lead to a natural modular architecture in the figure.}

\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{../figs/Arch.eps}
\caption[General Architecture]{General Architecture of ABS API and Java Language Backend}
\label{fig:arch}
\end{figure}

\section{Literature Overview}
\label{sec:intro:rel}

We discuss a brief overview of related work in the context of programming languages, actor model, and concurrency.
We divide the overview in two levels; one is at the level of the programming languages and the other is for the external (third-party) libraries developed for programming languages.

\subsection{Programming Languages}
\label{sec:intro:proglangs}

In this section, we briefly provide an overview of the programming languages that have targetted similar problem statements.
Various programming languages, in the past decade, have emerged to provide an actor-based model of asynchronous message passing~\cite{philippsen2000survey}.
We observe different classes of actor model and concurrent model of 
programming.
Table~\ref{tbl:actor:pl} presents a summary.

\begin{description}
\item[First-Class Citizen]
Languages in which the actor model is by-design part of the syntax and 
semantics of the language.
Pony~\cite{ponylang,ClebschD13} targets high-performance 
computing using actor models and shared memory. 
When actor model is part of the design of a language, formal verification
and correctness of actor semantics at runtime yields naturally from the 
language semantics at runtime.
\item[Implicit By Design]
refers to the type that there is no explicit notion of actor models in the language syntax or semantics.
However, the programming language provides fundamental constructs for concurrency and asynchronous message passing.
Thus, it becomes an easy task in this kind of programming language to create an abstraction to support the actor model by coding.
\item[External Library]
refers to the type of programming languages for which actor model support is provided by an external library developed for the language.
\end{description}


\begin{table}[t]
\centering
\begin{tabular}{lll}
\textsfb{Language} & \textsfb{Abstraction} & \textsfb{Type} 
\\ \toprule
Erlang\cite{erlang:armstrong,erlang:actor} & Process & Implicit By Design 
\\ \midrule
Elixir\cite{elixir,elixir:actor} & Agent & Implicit By Design 
\\ \midrule
Haskell\cite{con_haskell:wiki} & forkIO \& MVars & Implicit By Design 
\\ \midrule
Go\cite{go:actor} & Goroutine & Implicit By Design 
\\ \midrule
Rust\cite{rust:2014,rust:actor} & Send \& Sync & Implicit By Design 
\\ \midrule
Scala\cite{haller09tcs} & Akka Actors
\footnote{Scala 2.11.0 adopts Akka as default actor model implementation: \url{http://docs.scala-lang.org/overviews/core/actors-migration-guide.html}}
& External Library 
\\ \bottomrule
\end{tabular}
\caption{Actor Model Support in Programming Languages}
\label{tbl:actor:pl}
\end{table}

\subsection{Frameworks and Libraries}
\label{sec:intro:libs}

Since programming languages faced challenges to provide the necessary syntax 
and semantics for actor model and concurrency at the level of the language, 
many libraries and frameworks aim to fill this gap 
Table~\ref{tbl:actor:libs} presents a summary.
We observe that the more the language itself is close to the actor model 
semantics, the less external libraries and frameworks target this gap. 
In the following, we briefly enumerate frameworks
\footnote{A more comprehensive list can be obtained at \cite{KarmaniSA09} and  \url{https://en.wikipedia.org/wiki/Actor_model\#Programming_with_Actors}}
and libraries for Java.

\begin{table}[t]
\centering
\begin{tabular}{lll}
\textsfb{Library} & \textsfb{Technique} & \textsfb{JVM Language} 
\\ \toprule
Killim\cite{srinivasan2008kilim,kilim} & Byte-Code Modification & Java 
\\ \midrule
Quasar\cite{quasar} & Byte-Code Modification, Java~8 & Clojure, Java 
\\ \midrule
Akka\cite{akka,scala:actors:ordersky} & Scala Byte-Code on JVM & Scala, Java 
\\ \bottomrule
\end{tabular}
\caption{Actor programming libraries in Java}
\label{tbl:actor:libs}
\end{table}

One of the main techniques used in libraries to deliver actor programming in 
Java is byte-code engineering~\cite{dahm1999byte,bruneton2002asm,asm}.
Byte-code engineering modifies the generated byte-code for compiled classes in 
Java either during compilation or at runtime.
Although, this technique is commonly used and argued to provide better 
performance optimization~\cite{vallee1999soot}, it introduces other challenges 
regarding the verification of the running 
byte-code~\cite{leroy2001java,leroy2003java}.

\section{Organization and Contributions}
\label{sec:intro:contribs}

Based on the problem statement and approach taken in this research, 
Table~\ref{tbl:thesis} summarizes the structure of this text:

\begin{table}[h]
\centering
\begin{tabular}{p{7cm}p{3cm}p{3cm}}
\textsfb{Topic} & \textsfb{Part} & \textsfb{Chapter/Section}
\\ \toprule
{Formalization of the mapping from ABS to Java including the operational semantics and ABS co-operative scheduling in Java} & Programming Model (Part~\ref{p:model}) & Chapter~\ref{ch:p01:ch01} and \ref{ch:p01:ch02}
\\ \midrule
Design and implementation of ABS concurrency layer in Java & Implementation (Part~\ref{p:impl}) & Chapter~\ref{ch:p02:ch01} and \ref{ch:p02:ch02}
\\ \midrule 
Monitoring method call sequences using annotations & Application (Part~\ref{p:app}) & Chapter~\ref{ch:p03:ch02}
\\ \midrule
Design and implementation of a massive-scale monitoring system based on ABS API in Java & Application (Part~\ref{p:app}) & Chapter~\ref{ch:p03:ch01}
\\ \bottomrule 
\end{tabular}
\caption{Thesis Contributions Summary}
\label{tbl:thesis}
\end{table}

In addition, Table~\ref{tbl:papers} summarizes the conference and journal 
publications as a result of this research:

\begin{table}[h]
\centering
\begin{tabular}{p{7cm}p{5cm}p{1cm}}
\textsfb{Topic} & \textsfb{Proceedings / Journal} & \textsfb{Year}   
\\ \toprule
Programming and Deployment of Active Objects with Application-Level Scheduling & ACM SAC 2012, Pages 1883--1888 & 2012 
\\ \midrule
The Future of a Missed Deadline & COORD 2013, Pages 181--195 & 2013 
\\ \midrule
Monitoring Method Call Sequences using Annotations & Journal of Science of Computer Programming, 2014, Volume 94, Part 3, Pages 362--378 & 2014 
\\ \midrule
Programming with actors in Java~8 & ISoLA 2014, Pages 37--53 & 2014 
\\ \midrule
Formal verification of service level agreements through distributed monitoring & ESOCC 2015, Pages 125--140 & 2015
\\ \bottomrule
\end{tabular}
\caption{Actors At Work -- Conference and Journal Publications}
\label{tbl:papers}
\end{table}
